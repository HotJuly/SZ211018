# Vue生命周期

1. 请问Vue一共具有多少个生命周期?
   1. 一共具有11个,常用8个
2. 生命周期阶段划分
   1. 初始化阶段
      1. beforeCreate
      2. created
         1. 发送请求
            1. 优点:相比于mounted发送请求,此处发送时机会更早,相对来说返回数据的时间也会更早
            2. 缺点:如果在created中执行大量耗时的代码,那么后续代码的解析将会跟着延迟,最终导致页面白屏时间增加
            3. 注意:禁止在created阶段做复杂的逻辑操作
      3. beforeMount
      4. mounted
         1. 发送请求
            1. 优点:执行该生命周期的时候,页面已经挂载结束,可以看到页面了,此时做任何事情都不会影响到页面的渲染,也就是说减少了白屏时间
            2. 缺点:相比于created发送请求,此处发送时机会更晚,相对来说返回数据的时间也会更晚
         2. 操作真实DOM
            1. Swiper
            2. 滑动库
         3. 开启定时器
         4. 绑定自定义事件,绑定全局事件总线
   2. 更新阶段
      1. beforeUpdate
         1. 此时页面还没有更新,但是状态数据已经是最新值
      2. updated
         1. 此时页面已经更新,而且状态数据也是最新值
         2. 此时可以执行与DOM相关的事情,例如:刷新Swiper等
   3. 卸载阶段
      1. beforeDestroy
         1. 关闭定时器
         2. 解绑事件
            1. 如果是通过@符在模版中绑定的原生DOM事件,请问需不需要手动解绑?
               1. **不需要,因为@符经过了Vue的解析,他知道绑定了哪些事件,会自动解绑**
            2. 如果是通过onclick或者addEventListener语法绑定的原生DOM事件,请问需不需要手动解绑?
               1. **需要,因为该类语法并没有经过Vue的解析,他不知道绑定了哪些事件**
            3. 如果是通过@符或者$on语法绑定的组件自定义事件,请问需不需要手动解绑?
               1. **不需要,Vue会记录组件身上具有哪些自定义事件,在卸载组件的时候,会自动解绑**
            4. 如果是绑定在全局事件总线对象身上的自定义事件,请问需不需要手动解绑?
               1. **需要,因为组件写在的时候,不会写在全局事件总线对象,最终导致自定义事件残留在$bus身上,越堆越多**
      2. destroyed
   4. keep-alive专用
      1. 由于被keep-alive包裹的组件会失去他的初始化阶段和卸载阶段的生命周期,所以Vue提供了两个生命周期用于监视被缓存组件的显示隐藏
      2. activated(激活)
         1. 当被缓存的组件显示的时候,会执行该生命周期
      3. deactivated(失活)
         1. 当被缓存的组件隐藏的时候,会执行该生命周期
   5. 捕获报错专用
      1. errorCaptured
   6. Vue后端渲染专用
      1. serverPrefetch