# 组件懒加载

1. 前言
   1. Vue项目使用生产环境编译之后,打包得到的dist文件夹中,具有以下文件
      1. index.html
      2. index.js
      3. 小总结:说明当前js文件中,具有当前项目中绝大多数的代码,包括了js,css,vue等文件代码,以及体积较小的图片等资源
   2. 假设:现在有一个项目,该项目具有10个组件,每个组件大小为1MB
      1. 那么此时使用生产环境打包,js文件的体积大约是10MB,相当于是10个组件的总和
      2. 用户展示页面流程:
         1. 用户在浏览器地址栏中输入链接,浏览器请求该链接
         2. 服务器接收到浏览器的请求,返回index.html文件
         3. 浏览器接收到index.html文件,开始进行解析
         4. 浏览器发现index.html中需要使用到index.js文件,于是发送请求
         5. 服务器接收到浏览器的请求,服务器返回index.js文件
         6. 浏览器解析index.js文件,解析路由,最终对页面进行DOM的CRUD方法,实现页面展示
      3. 导致的问题:用户目前仅仅是查看了首页,但是实际上由于index.js中具有所有组件的代码,所以相当于用户一次性请求了10个组件的代码,无形中**增加了浏览器请求的数据量,增加了带宽的压力,延长了请求文件所花费的时间,增加了解析代码所需要的时间,最终导致页面首屏渲染变慢,页面白屏时间增加**
2. ES6模块化语法
   1. import ... from '路径'
      1. 静态引入
      2. 使用该语法引入的代码,在项目编译的时候,该语法会被对应文件的代码所取代,最终所有的代码会被汇总成一个文件
      3. 该语法在上线之后不存在
   2. import('路径')
      1. 动态引入
      2. 使用该语法引入的代码,在项目编译的时候,webpack如果发现import函数,那么被其引入的文件会被单独切割成一个js文件存放
      3. 该语法在上线之后依旧存在
3. 组件懒加载的优点
   1. 假设:现在有一个项目,该项目具有10个组件,每个组件大小为1MB,除了首页组件以外,其余组件都是用import函数进行引入
      1. 那么当代码以生产环境打包结束之后,dist文件中,就会存在1+1+9=11个文件
         1. 1个index.html
         2. 1个index.js
         3. 9个组件的js文件
         4. 小总结:由于其余9个组件的代码都被单独切割成js文件,所以index.js中只存在首页相关的代码,index.js大小为1MB,其余的组件js文件大小为1MB
   2. 由于index.js文件体积变小,所以此时**请求的数据量减少,降低了网络带宽的压力,较少了请求文件所花费的时间,较少了解析代码所需要的时间,最终导致页面首屏渲染变快,页面白屏时间变短**
4. 组件懒加载的缺点
   1. 由于进行组件懒加载之后,首次只会请求会首页代码,其余页面代码并没有请求回来,所以当用户切换到没使用过组件时候,需要发送请求,找服务器获取对应页面的js文件
   2. 最终导致,虽然首屏加载速度变快,但是后续页面加载速度变慢,都会出现少量白屏效果
   3. 相当于是将首页白屏的时间,分摊到每个页面第一次显示的时候
5. 组件预加载
   1. 趁着用户不注意,而且CPU空闲的时候,悄悄地发送请求,获取未来可能需要用到的组件代码
      1. 也就是说,当用户请求首页的代码时,趁用户不注意,提前加载后续页面的代码,当用户切换显示组件时,对应组件的代码已经存在内存中了
      2. 小总结:**组件预加载和不实现组件懒加载时的区别,就是组件预加载会优先保证首页的渲染,其次才会找空余时间请求后续页面代码**
   2. 优点:可以弥补组件懒加载的缺点,提高后续页面的渲染速度,让后续页面的显示不需要在等待网络请求的延迟时间
   3. 缺点:会比之前的情况更加浪费流量,可能会出现预加载回来的组件,用户根本不使用的情况