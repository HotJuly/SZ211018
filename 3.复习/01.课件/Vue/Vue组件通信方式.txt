1.props
	适用于父子组件通信
	父向子传参:
		1.父组件在子组件的标签上添加标签属性以及属性值
		2.子组件在配置对象中声明所需要接收的标签属性名称,作为props
		3.接收到的props都会变成当前组件实例对象上的属性

		父组件传递给子组件的是数据

	子向父传参:
		1.父组件在子组件的标签上添加标签属性以及属性值
			注意:属性值必须是父组件methods中的方法
		2.子组件在配置对象中声明所需要接收的标签属性名称,作为props
		3.子组件调用父组件传下来的函数,并向内部传入实参
		4.父组件的函数被成功调用,最终可以修改父组件自身的状态数据

		父组件传递给子组件的是函数

2.provide/inject
	适用于祖孙组件通信
	祖先向后代传参:
		1.父组件在配置对象中,添加provide属性,以及属性值
		2.子组件在配置对象中,添加inject属性,用于接收祖先组件传递下来的数据
		3.该属性就可以当做props进行使用

	注意点:
		1.inject向上查找数据的时候,会使用最近的满足条件的provide
		2.默认情况下provide暴露出去的数据不是响应式的
			如果想要实现响应式效果,必须提前准备好一个响应式对象

3.自定义事件
	$on	->	给某一个组件绑定一个自定义事件,需要提供事件名称和回调函数

	$once	->	效果与$on相同,唯一区别就是该自定义事件只能执行一次

	$off	->	用于解绑某个组件的自定义事件,根据传入的参数个数不同,效果不同
			如果传入消息名称和回调函数,那么就会解绑指定的自定义事件
			如果只传入消息名称,那么就会将该消息相关的所有自定义事件统统取消
			如果没传入参数,代表当前组件所有自定义事件全部取消

	$emit	->	用于触发某一个组件身上的某个自定义事件

	v-model
		对input框进行使用
			1.将指令的值作为默认值在input框中进行显示(属性名:value)
				    <input type="text" :value="num">
			2.当用户修改input框中的数据时,对应的状态数据会同步发生变化(事件名:input)
				     <input type="text" :value="num" @input="(event)=>{num=event.target.value}">

		对组件进行使用
			1.将指令的值作为标签属性值传递给子组件(默认属性名:value)
				<HelloWrold :value="msg"/>
			2.给子组件绑定自定义事件(默认事件名:input)
    				<HelloWorld :value="msg" @input="(data)=>msg=data" :fn="changeMsg"/>

			model属性可以实现对v-model的标签属性以及事件名进行自定义的操作

	.sync
		1.将指令的值作为标签属性值传递给子组件(属性名自定义)
    			<HelloWorldVue :num="num"/>
		2.给子组件绑定自定义事件(事件名称格式:"update: + 属性名")
    			<HelloWorldVue :num="num" @update:num="(data)=>{num=data}"/>

		注意:在Vue3中v-model名存实亡,语法还是写v-model,但是本质已经变成了.sync

	全局事件总线
		适用场景:
			1.订阅者和发布者同时存在
			2.订阅操作必须在发布之前
		流程:
			1.往Vue的原型对象身上注入$bus属性,属性值是一个Vue对象
				Vue.prototype.$bus = new Vue();

			2.在需要接收数据的组件内部,给$bus绑定自定义事件
				this.$bus.$on('getData',(data)=>{
      					console.log('getData',data)
   				 })

			3.在需要发布数据的组件内部,使用$emit触发$bus身上的自定义事件
   				 this.$bus.$emit('getData',123)

			注意点:
				全局事件总线流程中,自定义事件是绑定给$bus对象的,组件卸载的时候并不会影响到$bus的状态,也就是说之前绑定的自定义事件依旧存在
				所以,在组件卸载的时候,一定要将当前组件绑定的全局事件总线解绑


		

4.找到对应组件的对象
	$parent	->	用于获取到父组件的实例对象
	$root	->	用于获取到根组件的实例对象
	$children	->	用于获取到子组件实例对象组成的数组
		注意:$children 并不保证顺序，也不是响应式的
			操作该数组实例对象的排列顺序,不会影响到页面上的显示顺序

	$refs	->	用于收集模版中被进行了标记的内容(指添加了ref属性的节点)
		对标签使用
			可以获取到指定标签渲染之后的真实DOM节点

		对组件使用
			可以获取到指定的组件的实例对象

5.$attrs,$listeners
	$attrs->用于收集没有被props接收的组件标签属性
	$listeners->用于收集当前组件的所有自定义事件

6.插槽
	插槽适用于父子组件通信,插槽用于传递一段页面结构
		slot组件用于声明,之后接收到的插槽结构要渲染的位置
	插槽分为三种
	默认插槽
		流程:
			1.父组件在template中,向子组件的成对标签中间添加一段页面结构
			2.子组件在自己的template中,使用slot组件声明插槽渲染的位置
	具名插槽
		流程:
			1.父组件在template中,向子组件的成对标签中间添加一段页面结构
			2.父组件给对应的插槽结构取名(使用v-slot指令取名,格式:v-slot:名称)
			3.子组件在自己的template中,使用slot组件声明插槽渲染的位置,同时添加标签属性name="名称"

			其中默认插槽也有名字,就是default
	作用域插槽
		作用域插槽看起来像是子向父传参,但是实际上是子组件向插槽进行传参
		流程:
			1.父组件在template中,向子组件的成对标签中间添加一段页面结构
			2.父组件给对应的插槽结构取名(使用v-slot指令取名,格式:v-slot:名称)
			3.子组件在自己的template中,使用slot组件声明插槽渲染的位置,同时添加标签属性name="名称"
			4.子组件可以向slot组件传入一些标签属性以及数据
			5.父组件在插槽中,可以使用v-slot:footer="scope",使用scope变量接收所有传给slot组件的标签属性
				此处的scope类似于props
			6.在插槽中使用插值语法即可获取scope中的数据进行展示

7.Vuex
8.路由传参













