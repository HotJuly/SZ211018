# VueRouter原理分析

1. VueRouter的用处
   1. VueRouter是Vue的插件库(Vue.use)
   2. 使用他可以构建一个单页面应用(SPA)
   3. 问题:什么是单页面?
      1. 页面就是html文件
      2. 单页面应用就是一个项目只存在一个html文件
      3. 如果页面内部的内容需要发生变化,就是用原生DOM进行CRUD操作,来控制页面显示的内容
   4. 问题:Vue不使用VueRouter能否实现单页面应用?
      1. 不使用也可以实现
   5. 注意:由于当前VueRouter响应Vue3的号召,所以直接下载VueRouter,是4.0版本,不适用于Vue2.0项目,所以需要指定VueRouter的版本为3.0即可
2. VueRouter提供给我们的
   1. 构造函数
      1. 调用该构造函数可以获得路由器的实例对象
   2. 全局组件
      1. router-view
         1. 该组件用于显示匹配当前地址栏中地址的路由组件,相当于是占位符
         2. **原理:其实就是使用到了响应式原理,来切换页面显示的路由组件**
            1. **现象:当地址栏中的路由地址发生变化,页面会展示出最新的路由组件**
      2. router-link
         1. 如果用于点击该组件,就可以控制路由的跳转,跳转到指定的路由地址
         2. 他其实是声明式导航的一员:
            1. 问题:什么是声明式导航?
               1. **定义:通过标签的形式来引导用户进行跳转,这类方式成为声明式导航**
         3. **原理:router-link组件最终会生成a标签在页面上进行展示,会禁用a标签的默认行为,但是他回去修改路由地址,从而导致页面渲染出最新的路由组件(也就是说这里是一个伪跳转)**
   3. 公共对象
      1. $router
         1. 他是路由器的实例对象
         2. 它主要用于给开发者提供一些用于操作历史记录栈的API
            1. push
               1. 该API可以控制路由的切换跳转,会保留上一个路由的历史记录(可以回退到上一个路由)
               2. 问题:什么是编程式导航?
                  1. 定义:通过js的API来控制用户进行跳转,这种方式称之为编程式导航
               3. **原理:其实push方法就是使用了window.history.pushState方法**
            2. replace
               1. 该API可以控制路由的切换跳转,不会保留上一个路由的历史记录(无法回退到上一个路由)
               2. **原理:其实push方法就是使用了window.history.replaceState方法**
      2. $route
         1. 他是路由的实例对象
         2. 它主要用于给开发者提供一些与当前路由相关的数据
            1. fullpath->当前路由路径
            2. query->可以获取到当前路由的query数据,例如:"/home?username=xiaoming"
            3. params->可以获取到当前路由的params数据,例如:"/home/1001"
               1. params在使用的时候,需要提前给路由对象的path属性中声明占位符,例如:"path:'/home/:id ' "
            4. meta->该数据比较特殊,需要在声明路由对象的时候就添加好,当跳转到对应的路由时,可以通过该属性进行读取
3. 我们需要提供给VueRouter的东西
   1. 配置对象
      1. mode属性
         1. 数据类型:string
         2. 作用:用于声明当前VueRouter的运行模式
         3. 取值范围:
            1. hash
               1. 特征:地址栏中具有'/#/'就说明当前是hash模式
               2. 优点:
                  1. 兼容性好,兼容IE6+
                  2. 由于hash路由被浏览误认为是锚点,所以后续的前端路由不会发送给服务器,所以不需要做任何配置
               3. 缺点:
                  1. 长得太丑了,路径中带有#
                  2. 由于hash的路由路径中带有#,所以会被浏览器误以为是锚点功能
                     1. 最终导致锚点功能失效
               4. **原理:**
                  1. **其实hash模式,运用的就是window.location.hash来进行实现的**
                  2. **如果想要控制当前路由进行切换,只需要window.location.hash="地址值"即可**
                     1. **该方法是真正的在修改浏览器的历史记录栈,可以使用浏览器的会前进后退按钮**
                  3. **通过给window对象绑定hashchange事件,用于监视历史记录栈的变化,从而实现页面展示最新组件的效果**
            2. history
               1. 特征:地址栏中不具有'/#/'就说明当前是history模式
               2. 优点:
                  1. 颜值就是正义,长得好看
                  2. 锚点功能可以正常使用
               3. 缺点:
                  1. 兼容性差,兼容IE10+
                  2. **如果处于某个路由路径下,刷新当前浏览器,会出现404报错**
                     1. **原因:刷新浏览器的时候,浏览器会根据当前地址栏中的地址发送请求,导致前端路由被误认为是后端路由,而后端并没有该路由,就会 返回404**
                     2. **解决流程:**
                        1. **前端浏览器刷新,此时发送请求"http://localhost:8080/home",请求服务器**
                        2. **服务器接收到该请求,需要查找对应的API接口**
                        3. **如果服务器没有找到对应的API接口,要求后端返回index.html文件**
                           1. **要求后端没有的接口,统一返回index.html文件**
                        4. **服务器返回index.html文件,交给前端浏览器**
                        5. **浏览器解析当前index.html文件,并使用VueRouter来解析当前地址栏中的路由地址**
                        6. **将该路由地址作为前端路由进行解析,最终展示正确页面**
            3. **原理:**
               1. **history模式使用了HTML5新增的history对象实现对历史记录栈的操作**
               2. **通过给window绑定popstate事件,用于监视历史记录栈的变化,从而渲染最新的路由组件**
                  1. **注意:pushState和replaceState都无法触发该事件**
      2. routes属性
         1. 数据类型:routeObj[ ]
         2. 作用:用于收集存放当前项目中所有的路由信息
         3. routeObj对象
            1. path
               1. 数据类型:string
               2. 用于声明路由对应的路由地址
            2. component
               1. 数据类型:Function
               2. 当地址栏中的地址匹配对应的路由路径时,页面需要展示的路由组件















