<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    /*
      回调函数并不全是异步执行,也有部分回调函数会被同步执行
        1.数组相关方法
        2.Promise的构造器函数

      宏任务:
        1.setTimeout(定时器相关)
        2.事件相关
        3.ajax

      微任务:
        1.then
        2.mutationobserver

      注意:setTimeout可以开启宏任务,.then可以开启微任务

      流程:执行完所有的主线程代码->清空微任务队列->执行下一个宏任务(在流程2和3中循环)

      如果将script标签中的代码视为第一宏任务,那么宏任务优先
      如果将script标签中的代码不视为第一宏任务,那么微任务优先

      队列:其实他也是数组,只是对当前数组的操作方式不太相同
        先进先出,后进后出

      栈:其实他也是数组
        先进后出,后进先出
    
    */
    // [1, 2, 3].forEach(item => {
    //   console.log(item)
    // })
    // console.log('forEach()之后')

    // new Promise((resolve, reject) => { // excutor  执行器函数
    //   console.log('执行excutor')
    // })
    // console.log('new Promise()之后')

    // setTimeout(() => {
    //   console.log('执行timout回调')
    // }, 0);
    // console.log('setTimeout()之后')

    // Promise.resolve(1).then(() => {
    //   console.log('promise成功的回调')
    // })
    // Promise.resolve(1).then(() => {
    //   console.log('promise成功的回调')
    // })
    // console.log('.then之后')

    

    
    setTimeout(() => {
      console.log('1')
      
      Promise.resolve(1).then(() => {
        console.log('5')
      })
    }, 0);
    
    setTimeout(() => {
      console.log('2')
    }, 0);

    Promise.resolve(1).then(() => {
      console.log('3')
    })

    Promise.resolve(1).then(() => {
      console.log('4')
    })
    
  </script>
</body>
</html>